using Microsoft.Maui.Controls;
using Microsoft.Maui.Graphics; // Add this namespace for Color and Colors
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using CSimple.Services.AppModeService;
using CSimple.ViewModels;
using System.Diagnostics;
// Add for PathF
using Microsoft.Maui.Graphics.Text;

namespace CSimple.Pages
{
    // Ensure this class is partial and matches the x:Class in OrientPage.xaml
    public partial class OrientPage : ContentPage, IDrawable
    {
        private OrientPageViewModel _viewModel;
        private NodeViewModel _draggedNode = null;
        private PointF _dragStartPoint;
        private bool _isDrawingConnection = false;
        private PointF _connectionEndPoint;

        // Property to bind GraphicsView.Drawable to
        public IDrawable NodeDrawable => this;

        public OrientPage(OrientPageViewModel viewModel)
        {
            // This call is essential and should be generated by the build process.
            // If you get an error here, clean/rebuild the project.
            InitializeComponent();
            _viewModel = viewModel;
            BindingContext = _viewModel;

            // Optional: Set alert/actionsheet implementations if needed by VM
            _viewModel.ShowAlert = DisplayAlert;
            _viewModel.ShowActionSheet = (title, cancel, destruction, buttons) => DisplayActionSheet(title, cancel, destruction, buttons);

            // Invalidate canvas when VM collections change (basic example)
            // These lines depend on NodeCanvas being generated by InitializeComponent
            _viewModel.Nodes.CollectionChanged += (s, e) => NodeCanvas?.Invalidate();
            _viewModel.Connections.CollectionChanged += (s, e) => NodeCanvas?.Invalidate();
        }

        protected override void OnAppearing()
        {
            base.OnAppearing();
            Debug.WriteLine($"OrientPage Appearing.");
            // This depends on NodeCanvas being generated by InitializeComponent
            NodeCanvas?.Invalidate(); // Ensure canvas draws on appearing
        }

        protected override void OnNavigatedTo(NavigatedToEventArgs args)
        {
            base.OnNavigatedTo(args);
            Debug.WriteLine($"OrientPage NavigatedTo.");
        }

        // --- IDrawable Implementation ---
        public void Draw(ICanvas canvas, RectF dirtyRect)
        {
            // Use theme-aware background from XAML binding
            // Color backgroundColor = Application.Current.RequestedTheme == AppTheme.Dark ? Color.FromArgb("#1e1e1e") : Colors.WhiteSmoke;
            // canvas.FillColor = backgroundColor; // Background is set by GraphicsView BackgroundColor property in XAML
            // canvas.FillRectangle(dirtyRect); // No need to fill if background is set in XAML

            if (_viewModel == null) return;

            // Define theme-aware colors dynamically
            bool isDarkTheme = Application.Current.RequestedTheme == AppTheme.Dark;

            Color nodeStrokeColor = isDarkTheme ? Colors.SlateGray : Colors.DarkGray;
            Color selectedStrokeColor = Colors.OrangeRed; // Keep selection color consistent
            Color connectionColor = isDarkTheme ? Color.FromArgb("#9E9E9E") : Colors.Gray;
            Color highlightedConnectionColor = Colors.Orange; // Keep highlight color consistent
            Color nodeTextColor = isDarkTheme ? Colors.WhiteSmoke : Colors.Black;
            // Use colors that contrast well in both themes
            Color inputNodeFill = isDarkTheme ? Color.FromArgb("#2a527a") : Colors.LightSkyBlue;
            Color modelNodeFill = isDarkTheme ? Color.FromArgb("#7a7a3d") : Colors.LightGoldenrodYellow;
            Color shadowColor = Colors.Black.WithAlpha(isDarkTheme ? 0.6f : 0.4f); // Darker shadow in dark mode? Or lighter? Adjust as needed.
            Color tempConnectionColor = Colors.DodgerBlue; // Keep temp connection color consistent

            // 1. Draw Connections
            canvas.StrokeSize = 2;
            foreach (var connection in _viewModel.Connections)
            {
                var sourceNode = _viewModel.Nodes.FirstOrDefault(n => n.Id == connection.SourceNodeId);
                var targetNode = _viewModel.Nodes.FirstOrDefault(n => n.Id == connection.TargetNodeId);

                if (sourceNode != null && targetNode != null)
                {
                    bool isHighlighted = _viewModel.SelectedNode != null &&
                                         (_viewModel.SelectedNode.Id == sourceNode.Id || _viewModel.SelectedNode.Id == targetNode.Id);

                    Color lineColor = isHighlighted ? highlightedConnectionColor : connectionColor;
                    canvas.StrokeColor = lineColor;
                    canvas.FillColor = lineColor;

                    PointF start = GetConnectionPoint(sourceNode, targetNode.Position);
                    PointF end = GetConnectionPoint(targetNode, sourceNode.Position);

                    // Draw line
                    canvas.DrawLine(start, end);

                    // Draw Arrowhead
                    DrawArrowhead(canvas, start, end);
                }
            }

            // 2. Draw Temporary Connection Line (if drawing)
            if (_isDrawingConnection && _viewModel._temporaryConnectionState is NodeViewModel startNode)
            {
                canvas.StrokeColor = tempConnectionColor;
                canvas.FillColor = tempConnectionColor; // Set fill for arrowhead
                canvas.StrokeDashPattern = new float[] { 4, 4 };
                canvas.StrokeSize = 2;
                PointF tempStart = GetConnectionPoint(startNode, _connectionEndPoint);
                canvas.DrawLine(tempStart, _connectionEndPoint);
                DrawArrowhead(canvas, tempStart, _connectionEndPoint); // Draw arrow on temp line too
                canvas.StrokeDashPattern = null; // Reset dash pattern
                canvas.StrokeSize = 1; // Reset stroke size
            }


            // 3. Draw Nodes (Draw connections first so nodes are on top)
            foreach (var node in _viewModel.Nodes)
            {
                RectF nodeRect = new RectF(node.Position, node.Size);

                // Apply shadow
                canvas.SetShadow(offset: new SizeF(2, 2), blur: 5, color: shadowColor);

                // Node background and border
                canvas.FillColor = node.Type == NodeType.Input ? inputNodeFill : modelNodeFill;
                canvas.FillRoundedRectangle(nodeRect, 8); // Slightly more rounded

                // Reset shadow for border and text
                canvas.SetShadow(offset: new SizeF(0, 0), blur: 0, color: Colors.Transparent);

                // Border
                canvas.StrokeSize = node.IsSelected ? 3 : 1;
                canvas.StrokeColor = node.IsSelected ? selectedStrokeColor : nodeStrokeColor;
                canvas.DrawRoundedRectangle(nodeRect, 8);

                // Node text - with padding
                canvas.FontColor = nodeTextColor;
                canvas.FontSize = 12;
                float padding = 8f;
                RectF textRect = new RectF(nodeRect.X + padding, nodeRect.Y + padding, nodeRect.Width - 2 * padding, nodeRect.Height - 2 * padding);
                canvas.DrawString(node.Name, textRect, HorizontalAlignment.Center, VerticalAlignment.Center, TextFlow.OverflowBounds); // Use OverflowBounds
            }
        }

        // Helper to draw an arrowhead at the end of a line
        private void DrawArrowhead(ICanvas canvas, PointF start, PointF end)
        {
            float arrowLength = 10;
            // float arrowWidth = 5; // Removed unused variable

            double angle = Math.Atan2(end.Y - start.Y, end.X - start.X);

            // Calculate points for the arrowhead triangle
            PointF p1 = new PointF(end.X - arrowLength * (float)Math.Cos(angle - Math.PI / 6),
                                   end.Y - arrowLength * (float)Math.Sin(angle - Math.PI / 6));
            PointF p2 = new PointF(end.X - arrowLength * (float)Math.Cos(angle + Math.PI / 6),
                                   end.Y - arrowLength * (float)Math.Sin(angle + Math.PI / 6));

            // Create path for the arrowhead
            PathF arrowPath = new PathF();
            arrowPath.MoveTo(end);
            arrowPath.LineTo(p1);
            arrowPath.LineTo(p2);
            arrowPath.Close();

            // Fill the arrowhead
            canvas.FillPath(arrowPath); // Fill color will be the current stroke color
        }

        // Helper to get center point for connections (can be improved)
        private PointF GetConnectionPoint(NodeViewModel node, PointF targetPoint)
        {
            // Simple center point - could be improved to connect to nearest side
            return new PointF(node.Position.X + node.Size.Width / 2, node.Position.Y + node.Size.Height / 2);
        }


        // --- Interaction Handlers ---
        // These handlers also depend on NodeCanvas being generated by InitializeComponent

        void OnCanvasStartInteraction(object sender, TouchEventArgs e)
        {
            PointF touchPoint = e.Touches[0];
            var tappedNode = _viewModel.GetNodeAtPoint(touchPoint);

            if (tappedNode != null)
            {
                // Check if tapping on a connection handle (if implemented)
                // For now, assume tap starts drag or connection

                // Simple check: Shift+Tap to start connection? Or dedicated handles?
                // Let's assume simple drag for now, connection logic needs refinement.

                _viewModel.SelectedNode = tappedNode; // Select the node
                _draggedNode = tappedNode;
                _dragStartPoint = touchPoint;
                _isDrawingConnection = false; // Reset connection drawing

                // Placeholder: How to initiate connection drawing?
                // Maybe a long press, or specific handles on the node?
                // For demo: Let's say tapping near the right edge starts connection
                if (touchPoint.X > tappedNode.Position.X + tappedNode.Size.Width - 15)
                {
                    _viewModel.StartConnection(tappedNode);
                    _isDrawingConnection = true;
                    _connectionEndPoint = touchPoint; // Initial end point
                    _draggedNode = null; // Don't drag if starting connection
                }
            }
            else
            {
                _viewModel.SelectedNode = null; // Deselect if tapping empty space
                _draggedNode = null;
                _viewModel.CancelConnection(); // Cancel any pending connection
                _isDrawingConnection = false;
            }
            NodeCanvas.Invalidate(); // Redraw for selection/connection feedback
        }

        void OnCanvasDragInteraction(object sender, TouchEventArgs e)
        {
            PointF currentPoint = e.Touches[0];

            if (_draggedNode != null)
            {
                // Calculate delta and update node position in ViewModel
                float deltaX = currentPoint.X - _dragStartPoint.X;
                float deltaY = currentPoint.Y - _dragStartPoint.Y;
                PointF newPos = new PointF(_draggedNode.Position.X + deltaX, _draggedNode.Position.Y + deltaY);

                _viewModel.UpdateNodePosition(_draggedNode, newPos);

                _dragStartPoint = currentPoint; // Update start point for next delta
                NodeCanvas.Invalidate(); // Request redraw
            }
            else if (_isDrawingConnection)
            {
                _connectionEndPoint = currentPoint;
                _viewModel.UpdatePotentialConnection(currentPoint); // Update VM state if needed
                NodeCanvas.Invalidate(); // Redraw temporary line
            }
        }

        void OnCanvasEndInteraction(object sender, TouchEventArgs e)
        {
            PointF endPoint = e.Touches[0]; // Use the first touch point

            if (_isDrawingConnection)
            {
                var targetNode = _viewModel.GetNodeAtPoint(endPoint);
                _viewModel.CompleteConnection(targetNode); // VM handles connection logic
                _isDrawingConnection = false;
            }

            _draggedNode = null; // Stop dragging
            NodeCanvas.Invalidate(); // Final redraw
        }

        void OnCanvasCancelInteraction(object sender, EventArgs e)
        {
            // Handle cancellation (e.g., touch moved off screen)
            _draggedNode = null;
            if (_isDrawingConnection)
            {
                _viewModel.CancelConnection();
                _isDrawingConnection = false;
                NodeCanvas.Invalidate();
            }
        }
    }
}
