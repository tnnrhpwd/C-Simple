using Microsoft.Maui.Controls;
using Microsoft.Maui.Graphics; // Add this namespace for Color and Colors
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using CSimple.Services.AppModeService;
using CSimple.ViewModels;
using System.Diagnostics;
// Add for PathF
using Microsoft.Maui.Graphics.Text;
using CSimple.Models; // Needed for NodeType

namespace CSimple.Pages
{
    // Ensure this class is partial and matches the x:Class in OrientPage.xaml
    public partial class OrientPage : ContentPage, IDrawable
    {
        private OrientPageViewModel _viewModel;
        private NodeViewModel _draggedNode = null;
        private PointF _dragStartPoint;
        private bool _isDrawingConnection = false;
        private PointF _connectionEndPoint;

        // Define handle size
        private const float HandleSize = 14f;
        private const float HandleOffset = 5f; // Offset below the node

        // Property to bind GraphicsView.Drawable to
        public IDrawable NodeDrawable => this;

        // Define data type colors
        private readonly Color TextDataColor = Color.FromArgb("#ADD8E6"); // Light Blue
        private readonly Color ImageDataColor = Color.FromArgb("#90EE90"); // Light Green
        private readonly Color AudioDataColor = Color.FromArgb("#FFB6C1"); // Light Pink
        private readonly Color DefaultModelColor = Color.FromArgb("#FFFFE0"); // Light Yellow (fallback)
        private readonly Color UnknownDataColor = Colors.LightGray;

        public OrientPage(OrientPageViewModel viewModel)
        {
            // This call is essential and should be generated by the build process.
            // If you get an error here, clean/rebuild the project.
            InitializeComponent();
            _viewModel = viewModel;
            BindingContext = _viewModel;

            // Optional: Set alert/actionsheet implementations if needed by VM
            _viewModel.ShowAlert = DisplayAlert;
            _viewModel.ShowActionSheet = (title, cancel, destruction, buttons) => DisplayActionSheet(title, cancel, destruction, buttons);

            // Invalidate canvas when VM collections change (basic example)
            // These lines depend on NodeCanvas being generated by InitializeComponent
            _viewModel.Nodes.CollectionChanged += (s, e) => NodeCanvas?.Invalidate();
            _viewModel.Connections.CollectionChanged += (s, e) => NodeCanvas?.Invalidate();
        }

        protected override async void OnAppearing()
        {
            base.OnAppearing();
            Debug.WriteLine($"OrientPage Appearing.");

            if (_viewModel != null)
            {
                // Load pipelines and the default/last used one
                await _viewModel.InitializeAsync();
            }
            else
            {
                Debug.WriteLine("ViewModel is null in OnAppearing, cannot initialize.");
            }

            NodeCanvas?.Invalidate(); // Ensure canvas draws on appearing
        }

        protected override void OnNavigatedTo(NavigatedToEventArgs args)
        {
            base.OnNavigatedTo(args);
            Debug.WriteLine($"OrientPage NavigatedTo.");
        }

        // --- IDrawable Implementation ---
        public void Draw(ICanvas canvas, RectF dirtyRect)
        {
            // Use theme-aware background from XAML binding
            // Color backgroundColor = Application.Current.RequestedTheme == AppTheme.Dark ? Color.FromArgb("#1e1e1e") : Colors.WhiteSmoke;
            // canvas.FillColor = backgroundColor; // Background is set by GraphicsView BackgroundColor property in XAML
            // canvas.FillRectangle(dirtyRect); // No need to fill if background is set in XAML

            if (_viewModel == null) return;

            // Define theme-aware colors dynamically
            bool isDarkTheme = Application.Current.RequestedTheme == AppTheme.Dark;

            Color nodeStrokeColor = isDarkTheme ? Colors.SlateGray : Colors.DarkGray;
            Color selectedStrokeColor = Colors.OrangeRed; // Keep selection color consistent
            Color connectionColor = isDarkTheme ? Color.FromArgb("#9E9E9E") : Colors.Gray;
            Color highlightedConnectionColor = Colors.Orange; // Keep highlight color consistent
            Color nodeTextColor = isDarkTheme ? Colors.WhiteSmoke : Colors.Black;
            // Use colors that contrast well in both themes
            Color shadowColor = Colors.Black.WithAlpha(isDarkTheme ? 0.6f : 0.4f); // Darker shadow in dark mode? Or lighter? Adjust as needed.
            Color tempConnectionColor = Colors.DodgerBlue; // Keep temp connection color consistent
            Color handleColor = Colors.Green; // Color for the '+' handle
            Color handleStrokeColor = isDarkTheme ? Colors.LightGreen : Colors.DarkGreen;
            Color legendBackgroundColor = isDarkTheme ? Color.FromArgb("#AA333333") : Color.FromArgb("#AAFFFFFF");
            Color legendTextColor = nodeTextColor;

            // Log node positions for comparison
            // Debug.WriteLine("--- Drawing Nodes ---");
            // foreach(var node in _viewModel.Nodes) { Debug.WriteLine($"Node: {node.Name}, Pos: {node.Position}, Size: {node.Size}"); }
            // Debug.WriteLine("--- End Drawing Nodes ---");


            // 1. Draw Connections
            canvas.StrokeSize = 2;
            // Debug.WriteLine($"--- Drawing {_viewModel.Connections.Count} Connections ---");
            foreach (var connection in _viewModel.Connections)
            {
                var sourceNode = _viewModel.Nodes.FirstOrDefault(n => n.Id == connection.SourceNodeId);
                var targetNode = _viewModel.Nodes.FirstOrDefault(n => n.Id == connection.TargetNodeId);

                if (sourceNode != null && targetNode != null)
                {
                    // Debug.WriteLine($"Drawing connection from {sourceNode.Name} to {targetNode.Name}");
                    bool isHighlighted = _viewModel.SelectedNode != null &&
                                         (_viewModel.SelectedNode.Id == sourceNode.Id || _viewModel.SelectedNode.Id == targetNode.Id);

                    Color lineColor = isHighlighted ? highlightedConnectionColor : connectionColor;
                    canvas.StrokeColor = lineColor;
                    canvas.FillColor = lineColor; // For arrowhead fill

                    PointF start = GetConnectionPoint(sourceNode, targetNode.Position);
                    PointF end = GetConnectionPoint(targetNode, sourceNode.Position);

                    // Draw line
                    canvas.DrawLine(start, end);

                    // Draw Simplified Arrowhead
                    DrawArrowhead(canvas, start, end);
                }
                // else { Debug.WriteLine($"Connection skipped: Source or Target node not found (SourceId: {connection.SourceNodeId}, TargetId: {connection.TargetNodeId})"); }
            }
            // Debug.WriteLine($"--- Finished Drawing Connections ---");


            // 2. Draw Temporary Connection Line (if drawing)
            if (_isDrawingConnection && _viewModel._temporaryConnectionState is NodeViewModel startNode)
            {
                // Debug.WriteLine($"Drawing temporary line from {startNode.Name} to {_connectionEndPoint}");
                canvas.StrokeColor = tempConnectionColor;
                canvas.FillColor = tempConnectionColor; // Set fill for arrowhead
                canvas.StrokeDashPattern = new float[] { 4, 4 };
                canvas.StrokeSize = 2;
                PointF tempStart = GetConnectionPoint(startNode, _connectionEndPoint);
                canvas.DrawLine(tempStart, _connectionEndPoint);
                DrawArrowhead(canvas, tempStart, _connectionEndPoint); // Draw arrow on temp line too
                canvas.StrokeDashPattern = null; // Reset dash pattern
                canvas.StrokeSize = 1; // Reset stroke size
            }


            // 3. Draw Nodes (Draw connections first so nodes are on top)
            foreach (var node in _viewModel.Nodes)
            {
                RectF nodeRect = new RectF(node.Position, node.Size);

                // Determine Node Fill Color based on Data Type
                Color nodeFillColor = GetNodeColor(node);

                // Apply shadow
                canvas.SetShadow(offset: new SizeF(2, 2), blur: 5, color: shadowColor);

                // Node background and border
                canvas.FillColor = nodeFillColor; // Use data type color
                canvas.FillRoundedRectangle(nodeRect, 8); // Slightly more rounded

                // Reset shadow for border and text
                canvas.SetShadow(offset: new SizeF(0, 0), blur: 0, color: Colors.Transparent);

                // Border
                canvas.StrokeSize = node.IsSelected ? 3 : 1;
                canvas.StrokeColor = node.IsSelected ? selectedStrokeColor : nodeStrokeColor;
                canvas.DrawRoundedRectangle(nodeRect, 8);

                // Node text - with padding
                canvas.FontColor = nodeTextColor;
                canvas.FontSize = 12;
                float padding = 8f;
                RectF textRect = new RectF(nodeRect.X + padding, nodeRect.Y + padding, nodeRect.Width - 2 * padding, nodeRect.Height - 2 * padding);
                canvas.DrawString(node.Name, textRect, HorizontalAlignment.Center, VerticalAlignment.Center, TextFlow.OverflowBounds); // Use OverflowBounds

                // Draw Connection Handle (+) for Input and Model nodes
                if (node.Type == NodeType.Input || node.Type == NodeType.Model)
                {
                    RectF handleRect = GetConnectionHandleRect(node);
                    canvas.FillColor = handleColor;
                    canvas.StrokeColor = handleStrokeColor;
                    canvas.StrokeSize = 1;

                    // Draw circle handle
                    canvas.FillCircle(handleRect.Center.X, handleRect.Center.Y, HandleSize / 2);
                    canvas.DrawCircle(handleRect.Center.X, handleRect.Center.Y, HandleSize / 2);

                    // Draw '+' inside the handle
                    canvas.StrokeColor = Colors.White; // Color for the '+' symbol
                    canvas.StrokeSize = 1.5f;
                    float plusSize = HandleSize * 0.4f; // Size of the '+' lines
                    canvas.DrawLine(handleRect.Center.X - plusSize, handleRect.Center.Y, handleRect.Center.X + plusSize, handleRect.Center.Y); // Horizontal line
                    canvas.DrawLine(handleRect.Center.X, handleRect.Center.Y - plusSize, handleRect.Center.X, handleRect.Center.Y + plusSize); // Vertical line
                }
            }

            // 4. Draw Legend
            DrawLegend(canvas, dirtyRect, legendBackgroundColor, legendTextColor);
        }

        // Helper to draw a simplified arrowhead (triangle)
        private void DrawArrowhead(ICanvas canvas, PointF start, PointF end)
        {
            float arrowLength = 10;
            float arrowAngleDegrees = 30; // Angle of the arrowhead sides relative to the line

            double angle = Math.Atan2(end.Y - start.Y, end.X - start.X);
            double angleRad1 = angle + Math.PI - (arrowAngleDegrees * Math.PI / 180.0); // Angle for point 1
            double angleRad2 = angle + Math.PI + (arrowAngleDegrees * Math.PI / 180.0); // Angle for point 2

            // Calculate points for the arrowhead triangle relative to the end point
            PointF p1 = new PointF(end.X + arrowLength * (float)Math.Cos(angleRad1),
                                   end.Y + arrowLength * (float)Math.Sin(angleRad1));
            PointF p2 = new PointF(end.X + arrowLength * (float)Math.Cos(angleRad2),
                                   end.Y + arrowLength * (float)Math.Sin(angleRad2));

            // Create path for the arrowhead
            PathF arrowPath = new PathF();
            arrowPath.MoveTo(end); // Tip of the arrow
            arrowPath.LineTo(p1);  // One base point
            arrowPath.LineTo(p2);  // Other base point
            arrowPath.Close();     // Close back to the tip (forms a triangle)

            // Fill the arrowhead (FillColor should be set before calling this)
            canvas.FillPath(arrowPath);
        }

        // Helper to get center point for connections (can be improved)
        private PointF GetConnectionPoint(NodeViewModel node, PointF targetPoint)
        {
            // Simple center point - could be improved to connect to nearest side
            return new PointF(node.Position.X + node.Size.Width / 2, node.Position.Y + node.Size.Height / 2);
        }

        // Helper to get the rectangle for the connection handle
        private RectF GetConnectionHandleRect(NodeViewModel node)
        {
            float handleX = node.Position.X + (node.Size.Width / 2) - (HandleSize / 2);
            float handleY = node.Position.Y + node.Size.Height + HandleOffset;
            return new RectF(handleX, handleY, HandleSize, HandleSize);
        }

        // Helper to determine node color based on inferred data type
        private Color GetNodeColor(NodeViewModel node)
        {
            string nameLower = node.Name.ToLower();

            // Handle Input Nodes first
            if (node.Type == NodeType.Input)
            {
                if (nameLower.Contains("keyboard") || nameLower.Contains("mouse") || nameLower.Contains("text"))
                {
                    return TextDataColor;
                }
                else if (nameLower.Contains("camera") || nameLower.Contains("image") || nameLower.Contains("png"))
                {
                    return ImageDataColor;
                }
                else if (nameLower.Contains("audio") || nameLower.Contains("wav") || nameLower.Contains("mfcc"))
                {
                    return AudioDataColor;
                }
                else
                {
                    return UnknownDataColor; // Fallback for unknown input types
                }
            }
            // Handle Model Nodes
            else if (node.Type == NodeType.Model)
            {
                // Infer model's primary INPUT data type based on name keywords
                // Text Models
                if (nameLower.Contains("llm") || nameLower.Contains("language") || nameLower.Contains("text") ||
                    nameLower.Contains("gpt") || nameLower.Contains("bert") || nameLower.Contains("deepseek") ||
                    nameLower.Contains("llama") || nameLower.Contains("mistral"))
                {
                    return TextDataColor;
                }
                // Image Models
                else if (nameLower.Contains("vision") || nameLower.Contains("image") || nameLower.Contains("cnn") ||
                         nameLower.Contains("resnet") || nameLower.Contains("yolo") || nameLower.Contains("clip") ||
                         nameLower.Contains("segmentation") || nameLower.Contains("detection"))
                {
                    return ImageDataColor;
                }
                // Audio Models
                else if (nameLower.Contains("audio") || nameLower.Contains("speech") || nameLower.Contains("whisper") ||
                         nameLower.Contains("wav2vec") || nameLower.Contains("sound"))
                {
                    return AudioDataColor;
                }
                // Add more specific model type checks here if needed...

                // Fallback for models if type not inferred from name
                else
                {
                    return DefaultModelColor;
                }
            }
            // Fallback for any other node types (if they exist)
            else
            {
                return UnknownDataColor;
            }
        }

        // Helper to draw the legend
        private void DrawLegend(ICanvas canvas, RectF dirtyRect, Color backgroundColor, Color textColor)
        {
            float legendWidth = 100;
            float legendHeight = 70;
            float legendPadding = 10;
            float itemHeight = 15;
            float colorBoxSize = 10;

            // Position legend in top-right corner (adjust as needed)
            float legendX = dirtyRect.Width - legendWidth - legendPadding;
            float legendY = legendPadding; // Positioned below the toolbar area

            RectF legendRect = new RectF(legendX, legendY, legendWidth, legendHeight);

            // Draw background
            canvas.FillColor = backgroundColor;
            canvas.FillRoundedRectangle(legendRect, 5);

            // Draw legend items
            float currentY = legendY + legendPadding / 2;
            canvas.FontColor = textColor;
            canvas.FontSize = 10;

            // Text Item
            canvas.FillColor = TextDataColor;
            canvas.FillRectangle(legendX + legendPadding / 2, currentY, colorBoxSize, colorBoxSize);
            canvas.DrawString("Text Data", legendX + legendPadding / 2 + colorBoxSize + 5, currentY, legendWidth - colorBoxSize - legendPadding, itemHeight, HorizontalAlignment.Left, VerticalAlignment.Center);
            currentY += itemHeight;

            // Image Item
            canvas.FillColor = ImageDataColor;
            canvas.FillRectangle(legendX + legendPadding / 2, currentY, colorBoxSize, colorBoxSize);
            canvas.DrawString("Image Data", legendX + legendPadding / 2 + colorBoxSize + 5, currentY, legendWidth - colorBoxSize - legendPadding, itemHeight, HorizontalAlignment.Left, VerticalAlignment.Center);
            currentY += itemHeight;

            // Audio Item
            canvas.FillColor = AudioDataColor;
            canvas.FillRectangle(legendX + legendPadding / 2, currentY, colorBoxSize, colorBoxSize);
            canvas.DrawString("Audio Data", legendX + legendPadding / 2 + colorBoxSize + 5, currentY, legendWidth - colorBoxSize - legendPadding, itemHeight, HorizontalAlignment.Left, VerticalAlignment.Center);
            currentY += itemHeight;

            // Model Item (Default)
            canvas.FillColor = DefaultModelColor;
            canvas.FillRectangle(legendX + legendPadding / 2, currentY, colorBoxSize, colorBoxSize);
            canvas.DrawString("Model (Default)", legendX + legendPadding / 2 + colorBoxSize + 5, currentY, legendWidth - colorBoxSize - legendPadding, itemHeight, HorizontalAlignment.Left, VerticalAlignment.Center);
        }

        // --- Interaction Handlers ---
        // These handlers also depend on NodeCanvas being generated by InitializeComponent

        void OnCanvasStartInteraction(object sender, TouchEventArgs e)
        {
            PointF touchPoint = e.Touches[0];
            NodeViewModel nodeUnderHandle = null;
            bool handleTapped = false;

            // 1. Check if a connection handle was tapped FIRST
            foreach (var node in _viewModel.Nodes)
            {
                if (node.Type == NodeType.Input || node.Type == NodeType.Model)
                {
                    RectF handleRect = GetConnectionHandleRect(node);
                    handleRect.Inflate(2, 2); // Add tolerance

                    if (handleRect.Contains(touchPoint))
                    {
                        nodeUnderHandle = node;
                        handleTapped = true;
                        break; // Found the tapped handle
                    }
                }
            }

            if (handleTapped)
            {
                // Start connection drawing from the handle
                _viewModel.StartConnection(nodeUnderHandle);
                _isDrawingConnection = true;
                _connectionEndPoint = touchPoint; // Initial end point
                _draggedNode = null; // Don't drag if starting connection
                _viewModel.SelectedNode = nodeUnderHandle; // Select the node whose handle was tapped
                Debug.WriteLine($"Started connection from handle of {nodeUnderHandle.Name}");
                _draggedNode = null; // Explicitly ensure no dragging when starting connection
            }
            else
            {
                // 2. If no handle tapped, check if a node body was tapped
                var tappedNode = _viewModel.GetNodeAtPoint(touchPoint); // This should only check node body now

                if (tappedNode != null)
                {
                    // Select/Drag the node
                    _viewModel.SelectedNode = tappedNode;
                    _draggedNode = tappedNode;
                    _dragStartPoint = touchPoint;
                    _isDrawingConnection = false; // Ensure connection drawing is off
                    Debug.WriteLine($"Selected/Dragging node {tappedNode.Name}");
                }
                else
                {
                    // 3. Tapped empty space
                    _viewModel.SelectedNode = null;
                    _draggedNode = null;
                    _viewModel.CancelConnection();
                    _isDrawingConnection = false;
                    Debug.WriteLine("Tapped empty space.");
                }
            }

            NodeCanvas.Invalidate(); // Redraw for selection/connection feedback
            // Add log for start point
            Debug.WriteLine($"StartInteraction at {e.Touches[0]}");
        }

        void OnCanvasDragInteraction(object sender, TouchEventArgs e)
        {
            PointF currentPoint = e.Touches[0];
            // Add log for drag point
            // Debug.WriteLine($"DragInteraction at {currentPoint}");

            if (_draggedNode != null)
            {
                // Calculate delta and update node position in ViewModel
                float deltaX = currentPoint.X - _dragStartPoint.X;
                float deltaY = currentPoint.Y - _dragStartPoint.Y;
                PointF newPos = new PointF(_draggedNode.Position.X + deltaX, _draggedNode.Position.Y + deltaY);

                _viewModel.UpdateNodePosition(_draggedNode, newPos);

                _dragStartPoint = currentPoint; // Update start point for next delta
                NodeCanvas.Invalidate(); // Request redraw
            }
            else if (_isDrawingConnection)
            {
                _connectionEndPoint = currentPoint;
                // _viewModel.UpdatePotentialConnection(currentPoint); // Keep if VM uses it
                NodeCanvas.Invalidate(); // Redraw temporary line
            }
        }

        async void OnCanvasEndInteraction(object sender, TouchEventArgs e) // Made async
        {
            PointF endPoint = e.Touches[0]; // Use the first touch point
            Debug.WriteLine($"EndInteraction at {endPoint}. IsDrawingConnection: {_isDrawingConnection}");

            if (_isDrawingConnection)
            {
                Debug.WriteLine("Attempting to complete connection...");
                NodeViewModel targetNode = null;
                float tolerance = 20f; // Increased tolerance significantly for testing

                // Manually check for target node instead of relying solely on ViewModel method
                Debug.WriteLine($"--- Checking nodes at EndPoint {endPoint} with tolerance {tolerance} ---");
                foreach (var node in _viewModel.Nodes)
                {
                    // Create a slightly larger rectangle for hit testing
                    RectF nodeBounds = new RectF(node.Position, node.Size);
                    nodeBounds.Inflate(tolerance, tolerance);

                    Debug.WriteLine($"Checking Node: {node.Name}, Bounds (Inflated): {nodeBounds}");

                    if (nodeBounds.Contains(endPoint))
                    {
                        Debug.WriteLine($"   -> EndPoint {endPoint} IS within bounds of {node.Name}.");
                        // Ensure we are not connecting a node to itself (unless allowed by VM logic)
                        if (_viewModel._temporaryConnectionState is NodeViewModel sourceNode && sourceNode.Id != node.Id)
                        {
                            Debug.WriteLine($"   -> Valid target found: {node.Name}.");
                            targetNode = node;
                            break; // Found a valid target node
                        }
                        else if (_viewModel._temporaryConnectionState is NodeViewModel sourceNodeSelf)
                        {
                            Debug.WriteLine($"   -> Hit node {node.Name}, but it's the same as the start node ({sourceNodeSelf.Name}). Skipping.");
                        }
                        else
                        {
                            Debug.WriteLine($"   -> Hit node {node.Name}, but start node state is invalid. Skipping.");
                        }
                    }
                    else
                    {
                        Debug.WriteLine($"   -> EndPoint {endPoint} is NOT within bounds of {node.Name}.");
                    }
                }
                Debug.WriteLine($"--- Finished checking nodes ---");


                if (targetNode != null)
                {
                    Debug.WriteLine($"Found target node manually: {targetNode.Name}. Calling CompleteConnection.");
                    // *** IMPORTANT: Add logging INSIDE _viewModel.CompleteConnection ***
                    // *** to confirm it adds the connection to the ObservableCollection ***
                    _viewModel.CompleteConnection(targetNode);
                }
                else
                {
                    // Fallback check removed for clarity, focus on manual hit test first
                    Debug.WriteLine("No valid target node found manually at end point. Cancelling connection.");
                    _viewModel.CancelConnection(); // Explicitly cancel if ending on empty space
                }
                _isDrawingConnection = false; // Reset connection drawing state *after* handling
            }
            else if (_draggedNode != null)
            {
                Debug.WriteLine($"Ended drag for node: {_draggedNode.Name}");
                // Saving now happens during drag via UpdateNodePosition.
                // No need to call FinalizeNodeMove here anymore.
                await _viewModel.FinalizeNodeMove(); // Re-enabled this call
            }

            _draggedNode = null; // Stop dragging regardless of connection state
            // Invalidation should happen automatically due to CollectionChanged,
            // but an explicit call ensures redraw after state changes.
            NodeCanvas.Invalidate();
            Debug.WriteLine("EndInteraction finished.");
        }

        void OnCanvasCancelInteraction(object sender, EventArgs e)
        {
            Debug.WriteLine("CancelInteraction triggered.");
            // Handle cancellation (e.g., touch moved off screen)
            _draggedNode = null;
            if (_isDrawingConnection)
            {
                Debug.WriteLine("Cancelling connection drawing due to CancelInteraction.");
                _viewModel.CancelConnection();
                _isDrawingConnection = false;
                NodeCanvas.Invalidate();
            }
        }
    }
}
