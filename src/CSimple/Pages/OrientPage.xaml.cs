using Microsoft.Maui.Controls;
using Microsoft.Maui.Graphics; // Add this namespace for Color and Colors
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using CSimple.Services.AppModeService;
using CSimple.ViewModels;
using System.Diagnostics;
// Add for PathF
using Microsoft.Maui.Graphics.Text;

namespace CSimple.Pages
{
    // Ensure this class is partial and matches the x:Class in OrientPage.xaml
    public partial class OrientPage : ContentPage, IDrawable
    {
        private OrientPageViewModel _viewModel;
        private NodeViewModel _draggedNode = null;
        private PointF _dragStartPoint;
        private bool _isDrawingConnection = false;
        private PointF _connectionEndPoint;

        // Define handle size
        private const float HandleSize = 14f;
        private const float HandleOffset = 5f; // Offset below the node

        // Property to bind GraphicsView.Drawable to
        public IDrawable NodeDrawable => this;

        public OrientPage(OrientPageViewModel viewModel)
        {
            // This call is essential and should be generated by the build process.
            // If you get an error here, clean/rebuild the project.
            InitializeComponent();
            _viewModel = viewModel;
            BindingContext = _viewModel;

            // Optional: Set alert/actionsheet implementations if needed by VM
            _viewModel.ShowAlert = DisplayAlert;
            _viewModel.ShowActionSheet = (title, cancel, destruction, buttons) => DisplayActionSheet(title, cancel, destruction, buttons);

            // Invalidate canvas when VM collections change (basic example)
            // These lines depend on NodeCanvas being generated by InitializeComponent
            _viewModel.Nodes.CollectionChanged += (s, e) => NodeCanvas?.Invalidate();
            _viewModel.Connections.CollectionChanged += (s, e) => NodeCanvas?.Invalidate();
        }

        protected override void OnAppearing()
        {
            base.OnAppearing();
            Debug.WriteLine($"OrientPage Appearing.");
            // This depends on NodeCanvas being generated by InitializeComponent
            NodeCanvas?.Invalidate(); // Ensure canvas draws on appearing
        }

        protected override void OnNavigatedTo(NavigatedToEventArgs args)
        {
            base.OnNavigatedTo(args);
            Debug.WriteLine($"OrientPage NavigatedTo.");
        }

        // --- IDrawable Implementation ---
        public void Draw(ICanvas canvas, RectF dirtyRect)
        {
            // Use theme-aware background from XAML binding
            // Color backgroundColor = Application.Current.RequestedTheme == AppTheme.Dark ? Color.FromArgb("#1e1e1e") : Colors.WhiteSmoke;
            // canvas.FillColor = backgroundColor; // Background is set by GraphicsView BackgroundColor property in XAML
            // canvas.FillRectangle(dirtyRect); // No need to fill if background is set in XAML

            if (_viewModel == null) return;

            // Define theme-aware colors dynamically
            bool isDarkTheme = Application.Current.RequestedTheme == AppTheme.Dark;

            Color nodeStrokeColor = isDarkTheme ? Colors.SlateGray : Colors.DarkGray;
            Color selectedStrokeColor = Colors.OrangeRed; // Keep selection color consistent
            Color connectionColor = isDarkTheme ? Color.FromArgb("#9E9E9E") : Colors.Gray;
            Color highlightedConnectionColor = Colors.Orange; // Keep highlight color consistent
            Color nodeTextColor = isDarkTheme ? Colors.WhiteSmoke : Colors.Black;
            // Use colors that contrast well in both themes
            Color inputNodeFill = isDarkTheme ? Color.FromArgb("#2a527a") : Colors.LightSkyBlue;
            Color modelNodeFill = isDarkTheme ? Color.FromArgb("#7a7a3d") : Colors.LightGoldenrodYellow;
            Color shadowColor = Colors.Black.WithAlpha(isDarkTheme ? 0.6f : 0.4f); // Darker shadow in dark mode? Or lighter? Adjust as needed.
            Color tempConnectionColor = Colors.DodgerBlue; // Keep temp connection color consistent
            Color handleColor = Colors.Green; // Color for the '+' handle
            Color handleStrokeColor = isDarkTheme ? Colors.LightGreen : Colors.DarkGreen;

            // 1. Draw Connections
            canvas.StrokeSize = 2;
            foreach (var connection in _viewModel.Connections)
            {
                var sourceNode = _viewModel.Nodes.FirstOrDefault(n => n.Id == connection.SourceNodeId);
                var targetNode = _viewModel.Nodes.FirstOrDefault(n => n.Id == connection.TargetNodeId);

                if (sourceNode != null && targetNode != null)
                {
                    bool isHighlighted = _viewModel.SelectedNode != null &&
                                         (_viewModel.SelectedNode.Id == sourceNode.Id || _viewModel.SelectedNode.Id == targetNode.Id);

                    Color lineColor = isHighlighted ? highlightedConnectionColor : connectionColor;
                    canvas.StrokeColor = lineColor;
                    canvas.FillColor = lineColor;

                    PointF start = GetConnectionPoint(sourceNode, targetNode.Position);
                    PointF end = GetConnectionPoint(targetNode, sourceNode.Position);

                    // Draw line
                    canvas.DrawLine(start, end);

                    // Draw Arrowhead
                    DrawArrowhead(canvas, start, end);
                }
            }

            // 2. Draw Temporary Connection Line (if drawing)
            if (_isDrawingConnection && _viewModel._temporaryConnectionState is NodeViewModel startNode)
            {
                canvas.StrokeColor = tempConnectionColor;
                canvas.FillColor = tempConnectionColor; // Set fill for arrowhead
                canvas.StrokeDashPattern = new float[] { 4, 4 };
                canvas.StrokeSize = 2;
                PointF tempStart = GetConnectionPoint(startNode, _connectionEndPoint);
                canvas.DrawLine(tempStart, _connectionEndPoint);
                DrawArrowhead(canvas, tempStart, _connectionEndPoint); // Draw arrow on temp line too
                canvas.StrokeDashPattern = null; // Reset dash pattern
                canvas.StrokeSize = 1; // Reset stroke size
            }


            // 3. Draw Nodes (Draw connections first so nodes are on top)
            foreach (var node in _viewModel.Nodes)
            {
                RectF nodeRect = new RectF(node.Position, node.Size);

                // Apply shadow
                canvas.SetShadow(offset: new SizeF(2, 2), blur: 5, color: shadowColor);

                // Node background and border
                canvas.FillColor = node.Type == NodeType.Input ? inputNodeFill : modelNodeFill;
                canvas.FillRoundedRectangle(nodeRect, 8); // Slightly more rounded

                // Reset shadow for border and text
                canvas.SetShadow(offset: new SizeF(0, 0), blur: 0, color: Colors.Transparent);

                // Border
                canvas.StrokeSize = node.IsSelected ? 3 : 1;
                canvas.StrokeColor = node.IsSelected ? selectedStrokeColor : nodeStrokeColor;
                canvas.DrawRoundedRectangle(nodeRect, 8);

                // Node text - with padding
                canvas.FontColor = nodeTextColor;
                canvas.FontSize = 12;
                float padding = 8f;
                RectF textRect = new RectF(nodeRect.X + padding, nodeRect.Y + padding, nodeRect.Width - 2 * padding, nodeRect.Height - 2 * padding);
                canvas.DrawString(node.Name, textRect, HorizontalAlignment.Center, VerticalAlignment.Center, TextFlow.OverflowBounds); // Use OverflowBounds

                // Draw Connection Handle (+) for Input and Model nodes
                if (node.Type == NodeType.Input || node.Type == NodeType.Model)
                {
                    RectF handleRect = GetConnectionHandleRect(node);
                    canvas.FillColor = handleColor;
                    canvas.StrokeColor = handleStrokeColor;
                    canvas.StrokeSize = 1;

                    // Draw circle handle
                    canvas.FillCircle(handleRect.Center.X, handleRect.Center.Y, HandleSize / 2);
                    canvas.DrawCircle(handleRect.Center.X, handleRect.Center.Y, HandleSize / 2);

                    // Draw '+' inside the handle
                    canvas.StrokeColor = Colors.White; // Color for the '+' symbol
                    canvas.StrokeSize = 1.5f;
                    float plusSize = HandleSize * 0.4f; // Size of the '+' lines
                    canvas.DrawLine(handleRect.Center.X - plusSize, handleRect.Center.Y, handleRect.Center.X + plusSize, handleRect.Center.Y); // Horizontal line
                    canvas.DrawLine(handleRect.Center.X, handleRect.Center.Y - plusSize, handleRect.Center.X, handleRect.Center.Y + plusSize); // Vertical line
                }
            }
        }

        // Helper to draw an arrowhead at the end of a line
        private void DrawArrowhead(ICanvas canvas, PointF start, PointF end)
        {
            float arrowLength = 10;
            // float arrowWidth = 5; // Removed unused variable

            double angle = Math.Atan2(end.Y - start.Y, end.X - start.X);

            // Calculate points for the arrowhead triangle
            PointF p1 = new PointF(end.X - arrowLength * (float)Math.Cos(angle - Math.PI / 6),
                                   end.Y - arrowLength * (float)Math.Sin(angle - Math.PI / 6));
            PointF p2 = new PointF(end.X - arrowLength * (float)Math.Cos(angle + Math.PI / 6),
                                   end.Y - arrowLength * (float)Math.Sin(angle + Math.PI / 6));

            // Create path for the arrowhead
            PathF arrowPath = new PathF();
            arrowPath.MoveTo(end);
            arrowPath.LineTo(p1);
            arrowPath.LineTo(p2);
            arrowPath.Close();

            // Fill the arrowhead
            canvas.FillPath(arrowPath); // Fill color will be the current stroke color
        }

        // Helper to get center point for connections (can be improved)
        private PointF GetConnectionPoint(NodeViewModel node, PointF targetPoint)
        {
            // Simple center point - could be improved to connect to nearest side
            return new PointF(node.Position.X + node.Size.Width / 2, node.Position.Y + node.Size.Height / 2);
        }

        // Helper to get the rectangle for the connection handle
        private RectF GetConnectionHandleRect(NodeViewModel node)
        {
            float handleX = node.Position.X + (node.Size.Width / 2) - (HandleSize / 2);
            float handleY = node.Position.Y + node.Size.Height + HandleOffset;
            return new RectF(handleX, handleY, HandleSize, HandleSize);
        }

        // --- Interaction Handlers ---
        // These handlers also depend on NodeCanvas being generated by InitializeComponent

        void OnCanvasStartInteraction(object sender, TouchEventArgs e)
        {
            PointF touchPoint = e.Touches[0];
            NodeViewModel nodeUnderHandle = null;
            bool handleTapped = false;

            // 1. Check if a connection handle was tapped FIRST
            foreach (var node in _viewModel.Nodes)
            {
                if (node.Type == NodeType.Input || node.Type == NodeType.Model)
                {
                    RectF handleRect = GetConnectionHandleRect(node);
                    handleRect.Inflate(2, 2); // Add tolerance

                    if (handleRect.Contains(touchPoint))
                    {
                        nodeUnderHandle = node;
                        handleTapped = true;
                        break; // Found the tapped handle
                    }
                }
            }

            if (handleTapped)
            {
                // Start connection drawing from the handle
                _viewModel.StartConnection(nodeUnderHandle);
                _isDrawingConnection = true;
                _connectionEndPoint = touchPoint; // Initial end point
                _draggedNode = null; // Don't drag if starting connection
                _viewModel.SelectedNode = nodeUnderHandle; // Select the node whose handle was tapped
                Debug.WriteLine($"Started connection from handle of {nodeUnderHandle.Name}");
                _draggedNode = null; // Explicitly ensure no dragging when starting connection
            }
            else
            {
                // 2. If no handle tapped, check if a node body was tapped
                var tappedNode = _viewModel.GetNodeAtPoint(touchPoint); // This should only check node body now

                if (tappedNode != null)
                {
                    // Select/Drag the node
                    _viewModel.SelectedNode = tappedNode;
                    _draggedNode = tappedNode;
                    _dragStartPoint = touchPoint;
                    _isDrawingConnection = false; // Ensure connection drawing is off
                    Debug.WriteLine($"Selected/Dragging node {tappedNode.Name}");
                }
                else
                {
                    // 3. Tapped empty space
                    _viewModel.SelectedNode = null;
                    _draggedNode = null;
                    _viewModel.CancelConnection();
                    _isDrawingConnection = false;
                    Debug.WriteLine("Tapped empty space.");
                }
            }

            NodeCanvas.Invalidate(); // Redraw for selection/connection feedback
        }

        void OnCanvasDragInteraction(object sender, TouchEventArgs e)
        {
            PointF currentPoint = e.Touches[0];

            if (_draggedNode != null)
            {
                // Calculate delta and update node position in ViewModel
                float deltaX = currentPoint.X - _dragStartPoint.X;
                float deltaY = currentPoint.Y - _dragStartPoint.Y;
                PointF newPos = new PointF(_draggedNode.Position.X + deltaX, _draggedNode.Position.Y + deltaY);

                _viewModel.UpdateNodePosition(_draggedNode, newPos);

                _dragStartPoint = currentPoint; // Update start point for next delta
                NodeCanvas.Invalidate(); // Request redraw
            }
            else if (_isDrawingConnection)
            {
                _connectionEndPoint = currentPoint;
                _viewModel.UpdatePotentialConnection(currentPoint); // Update VM state if needed
                NodeCanvas.Invalidate(); // Redraw temporary line
            }
        }

        void OnCanvasEndInteraction(object sender, TouchEventArgs e)
        {
            PointF endPoint = e.Touches[0]; // Use the first touch point
            Debug.WriteLine($"EndInteraction at {endPoint}. IsDrawingConnection: {_isDrawingConnection}");

            if (_isDrawingConnection)
            {
                Debug.WriteLine("Attempting to complete connection...");
                NodeViewModel targetNode = null;
                float tolerance = 5f; // Add tolerance for easier tapping

                // Manually check for target node instead of relying solely on ViewModel method
                foreach (var node in _viewModel.Nodes)
                {
                    // Create a slightly larger rectangle for hit testing
                    RectF nodeBounds = new RectF(node.Position, node.Size);
                    nodeBounds.Inflate(tolerance, tolerance);

                    if (nodeBounds.Contains(endPoint))
                    {
                        // Ensure we are not connecting a node to itself (unless allowed by VM logic)
                        if (_viewModel._temporaryConnectionState is NodeViewModel startNode && startNode.Id != node.Id)
                        {
                            targetNode = node;
                            break; // Found a valid target node
                        }
                        // If connecting to self is allowed, remove the ID check above
                    }
                }


                if (targetNode != null)
                {
                    Debug.WriteLine($"Found target node manually: {targetNode.Name}");
                    _viewModel.CompleteConnection(targetNode); // VM handles connection logic (add/remove from collection)
                }
                else
                {
                    // Try the ViewModel method as a fallback, maybe it has specific logic
                    var vmTargetNode = _viewModel.GetNodeAtPoint(endPoint);
                    if (vmTargetNode != null && (_viewModel._temporaryConnectionState is NodeViewModel startNode && startNode.Id != vmTargetNode.Id))
                    {
                        Debug.WriteLine($"Found target node via VM method: {vmTargetNode.Name}");
                        _viewModel.CompleteConnection(vmTargetNode);
                        targetNode = vmTargetNode; // Mark as found
                    }
                    else
                    {
                        Debug.WriteLine("No target node found manually or via VM method at end point. Cancelling connection.");
                        _viewModel.CancelConnection(); // Explicitly cancel if ending on empty space
                    }
                }
                _isDrawingConnection = false; // Reset connection drawing state *after* handling
            }
            else if (_draggedNode != null)
            {
                Debug.WriteLine($"Ended drag for node: {_draggedNode.Name}");
                // Optional: Add any logic needed at the end of a drag, like snapping to grid
            }

            _draggedNode = null; // Stop dragging regardless of connection state
            // Invalidation should happen automatically due to CollectionChanged,
            // but an explicit call ensures redraw after state changes.
            NodeCanvas.Invalidate();
            Debug.WriteLine("EndInteraction finished.");
        }

        void OnCanvasCancelInteraction(object sender, EventArgs e)
        {
            Debug.WriteLine("CancelInteraction triggered.");
            // Handle cancellation (e.g., touch moved off screen)
            _draggedNode = null;
            if (_isDrawingConnection)
            {
                Debug.WriteLine("Cancelling connection drawing due to CancelInteraction.");
                _viewModel.CancelConnection();
                _isDrawingConnection = false;
                NodeCanvas.Invalidate();
            }
        }
    }
}
