using Microsoft.Maui.Controls;
using Microsoft.Maui.Graphics; // Add this namespace for Color and Colors
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using CSimple.Services.AppModeService;
using CSimple.ViewModels;
using System.Diagnostics;
// Add for PathF
using Microsoft.Maui.Graphics.Text;
using CSimple.Models; // Needed for NodeType

namespace CSimple.Pages
{
    public partial class OrientPage : ContentPage, IDrawable
    {
        private OrientPageViewModel _viewModel;
        private NodeViewModel _draggedNode = null;
        private PointF _dragStartPoint;
        private bool _isDrawingConnection = false;
        private PointF _connectionEndPoint;

        // Define handle size
        private const float HandleSize = 14f;
        private const float HandleOffset = 5f; // Offset below the node

        // Property to bind GraphicsView.Drawable to
        public IDrawable NodeDrawable => this;

        // Define data type colors
        private readonly Color TextDataColor = Color.FromArgb("#ADD8E6"); // Light Blue
        private readonly Color ImageDataColor = Color.FromArgb("#90EE90"); // Light Green
        private readonly Color AudioDataColor = Color.FromArgb("#FFB6C1"); // Light Pink
        private readonly Color DefaultModelColor = Color.FromArgb("#FFFFE0"); // Light Yellow (fallback)
        private readonly Color UnknownDataColor = Colors.LightGray;

        public OrientPage(OrientPageViewModel viewModel)
        {
            // This call is essential and should be generated by the build process.
            // If you get an error here, clean/rebuild the project.
            InitializeComponent();
            _viewModel = viewModel;
            BindingContext = _viewModel;

            // Optional: Set alert/actionsheet implementations if needed by VM
            _viewModel.ShowAlert = DisplayAlert;
            _viewModel.ShowActionSheet = (title, cancel, destruction, buttons) => DisplayActionSheet(title, cancel, destruction, buttons);

            // Register the canvas invalidation action
            _viewModel.InvalidateCanvas = InvalidateGraphicsView;

            // Invalidate canvas when VM collections change (basic example)
            // These lines depend on NodeCanvas being generated by InitializeComponent
            _viewModel.Nodes.CollectionChanged += (s, e) => NodeCanvas?.Invalidate();
            _viewModel.Connections.CollectionChanged += (s, e) => NodeCanvas?.Invalidate();

            // Remove the event handler setup that's no longer needed
            /*
            // Ensure we update our SelectedClassification when ViewModel's SelectedNode changes
            _viewModel.PropertyChanged += (s, e) => 
            {
                if (e.PropertyName == nameof(_viewModel.SelectedNode) && _viewModel.SelectedNode != null)
                {
                    // Update the picker selection to match the node's current classification
                    SelectedClassification = _viewModel.SelectedNode.Classification;
                    OnPropertyChanged(nameof(SelectedClassification));
                }
            };
            */
        }

        protected override async void OnAppearing()
        {
            base.OnAppearing();
            Debug.WriteLine($"OrientPage Appearing.");

            if (_viewModel != null)
            {
                // Ensure NetPageViewModel is loaded first
                var netPageVM = ((App)Application.Current).NetPageViewModel;
                if (netPageVM != null)
                {
                    Debug.WriteLine($"OnAppearing: NetPageViewModel found with {netPageVM.AvailableModels?.Count ?? 0} models");

                    // If NetPageViewModel has no models, load them first
                    if (netPageVM.AvailableModels == null || netPageVM.AvailableModels.Count == 0)
                    {
                        Debug.WriteLine("OnAppearing: NetPageViewModel has no models, loading them first");
                        await netPageVM.LoadDataAsync();
                        Debug.WriteLine($"OnAppearing: NetPageViewModel now has {netPageVM.AvailableModels?.Count ?? 0} models");
                    }
                }
                else
                {
                    Debug.WriteLine("OnAppearing: NetPageViewModel is null");
                }

                // Now initialize our own ViewModel (which will use the loaded models)
                await _viewModel.InitializeAsync();
            }
            else
            {
                Debug.WriteLine("ViewModel is null in OnAppearing, cannot initialize.");
            }

            NodeCanvas?.Invalidate(); // Ensure canvas draws on appearing
        }

        protected override void OnNavigatedTo(NavigatedToEventArgs args)
        {
            base.OnNavigatedTo(args);
            Debug.WriteLine($"OrientPage NavigatedTo.");
        }

        // --- IDrawable Implementation ---
        public void Draw(ICanvas canvas, RectF dirtyRect)
        {
            // Use theme-aware background from XAML binding
            // Color backgroundColor = Application.Current.RequestedTheme == AppTheme.Dark ? Color.FromArgb("#1e1e1e") : Colors.WhiteSmoke;
            // canvas.FillColor = backgroundColor; // Background is set by GraphicsView BackgroundColor property in XAML
            // canvas.FillRectangle(dirtyRect); // No need to fill if background is set in XAML

            if (_viewModel == null) return;

            // Define theme-aware colors dynamically
            bool isDarkTheme = Application.Current.RequestedTheme == AppTheme.Dark;

            Color nodeStrokeColor = isDarkTheme ? Colors.SlateGray : Colors.DarkGray;
            Color selectedStrokeColor = Colors.OrangeRed; // Keep selection color consistent
            Color connectionColor = isDarkTheme ? Color.FromArgb("#9E9E9E") : Colors.Gray;
            Color highlightedConnectionColor = Colors.Orange; // Keep highlight color consistent

            // Get theme-aware text colors from application resources
            Color nodeTextColor;
            if (Application.Current.Resources.TryGetValue(isDarkTheme ? "TextPrimaryDark" : "TextPrimaryLight", out object textColorObj))
            {
                nodeTextColor = (Color)textColorObj;
            }
            else
            {
                // Fallback if resource not found
                nodeTextColor = isDarkTheme ? Colors.WhiteSmoke : Colors.Black;
            }

            // Get theme-aware background colors
            Color cardBackground;
            if (Application.Current.Resources.TryGetValue(isDarkTheme ? "CardBackgroundDark" : "CardBackgroundLight", out object cardBgObj))
            {
                cardBackground = (Color)cardBgObj;
            }
            else
            {
                cardBackground = isDarkTheme ? Color.FromArgb("#1e1e1e") : Colors.White;
            }

            Color surfaceBackground;
            if (Application.Current.Resources.TryGetValue(isDarkTheme ? "SurfaceBackgroundDark" : "SurfaceBackgroundLight", out object surfaceBgObj))
            {
                surfaceBackground = (Color)surfaceBgObj;
            }
            else
            {
                surfaceBackground = isDarkTheme ? Color.FromArgb("#2a2a2a") : Color.FromArgb("#f0f0f0");
            }

            // Use colors that contrast well in both themes
            Color shadowColor = Colors.Black.WithAlpha(isDarkTheme ? 0.6f : 0.4f); // Darker shadow in dark mode? Or lighter? Adjust as needed.
            Color tempConnectionColor = Colors.DodgerBlue; // Keep temp connection color consistent
            Color handleColor = Colors.Green; // Color for the '+' handle
            Color handleStrokeColor = isDarkTheme ? Colors.LightGreen : Colors.DarkGreen;
            Color legendBackgroundColor = isDarkTheme ? Color.FromArgb("#AA333333") : Color.FromArgb("#AAFFFFFF");
            Color legendTextColor = nodeTextColor;

            // Log node positions for comparison
            // Debug.WriteLine("--- Drawing Nodes ---");
            // foreach(var node in _viewModel.Nodes) { Debug.WriteLine($"Node: {node.Name}, Pos: {node.Position}, Size: {node.Size}"); }
            // Debug.WriteLine("--- End Drawing Nodes ---");


            // 1. Draw Connections
            canvas.StrokeSize = 2;
            // Debug.WriteLine($"--- Drawing {_viewModel.Connections.Count} Connections ---");
            foreach (var connection in _viewModel.Connections)
            {
                var sourceNode = _viewModel.Nodes.FirstOrDefault(n => n.Id == connection.SourceNodeId);
                var targetNode = _viewModel.Nodes.FirstOrDefault(n => n.Id == connection.TargetNodeId);

                if (sourceNode != null && targetNode != null)
                {
                    // Debug.WriteLine($"Drawing connection from {sourceNode.Name} to {targetNode.Name}");
                    bool isHighlighted = _viewModel.SelectedNode != null &&
                                         (_viewModel.SelectedNode.Id == sourceNode.Id || _viewModel.SelectedNode.Id == targetNode.Id);

                    Color lineColor = isHighlighted ? highlightedConnectionColor : connectionColor;
                    canvas.StrokeColor = lineColor;
                    canvas.FillColor = lineColor; // For arrowhead fill

                    PointF start = GetConnectionPoint(sourceNode, targetNode.Position);
                    PointF end = GetConnectionPoint(targetNode, sourceNode.Position);

                    // Draw line
                    canvas.DrawLine(start, end);

                    // Draw Simplified Arrowhead
                    DrawArrowhead(canvas, start, end);
                }
                // else { Debug.WriteLine($"Connection skipped: Source or Target node not found (SourceId: {connection.SourceNodeId}, TargetId: {connection.TargetNodeId})"); }
            }
            // Debug.WriteLine($"--- Finished Drawing Connections ---");


            // 2. Draw Temporary Connection Line (if drawing)
            if (_isDrawingConnection && _viewModel._temporaryConnectionState is NodeViewModel startNode)
            {
                // Debug.WriteLine($"Drawing temporary line from {startNode.Name} to {_connectionEndPoint}");
                canvas.StrokeColor = tempConnectionColor;
                canvas.FillColor = tempConnectionColor; // Set fill for arrowhead
                canvas.StrokeDashPattern = new float[] { 4, 4 };
                canvas.StrokeSize = 2;
                PointF tempStart = GetConnectionPoint(startNode, _connectionEndPoint);
                canvas.DrawLine(tempStart, _connectionEndPoint);
                DrawArrowhead(canvas, tempStart, _connectionEndPoint); // Draw arrow on temp line too
                canvas.StrokeDashPattern = null; // Reset dash pattern
                canvas.StrokeSize = 1; // Reset stroke size
            }


            // 3. Draw Nodes (Draw connections first so nodes are on top)
            foreach (var node in _viewModel.Nodes)
            {
                RectF nodeRect = new RectF(node.Position, node.Size);

                // Determine Node Fill Color based on Data Type and Theme
                Color nodeFillColor = GetNodeColor(node, isDarkTheme, cardBackground, surfaceBackground);

                // Apply shadow
                canvas.SetShadow(offset: new SizeF(2, 2), blur: 5, color: shadowColor);

                // Node background and border
                canvas.FillColor = nodeFillColor; // Use data type color
                canvas.FillRoundedRectangle(nodeRect, 8); // Slightly more rounded

                // Reset shadow for border and text
                canvas.SetShadow(offset: new SizeF(0, 0), blur: 0, color: Colors.Transparent);

                // --- MODIFIED Border ---
                // Calculate base stroke size (selected or default)
                float baseStroke = node.IsSelected ? 3f : 1f;
                // Calculate ensemble bonus (only if input count > 1)
                // Increased multiplier from 0.75f to 1.5f for more distinct growth
                float ensembleBonus = node.EnsembleInputCount > 1 ? (node.EnsembleInputCount - 1) * 1.5f : 0f;
                canvas.StrokeSize = baseStroke + ensembleBonus; // Combine base and bonus
                // --- END MODIFIED Border ---

                canvas.StrokeColor = node.IsSelected ? selectedStrokeColor : nodeStrokeColor;
                canvas.DrawRoundedRectangle(nodeRect, 8);

                // Node text - with padding
                canvas.FontColor = nodeTextColor;
                canvas.FontSize = 12;
                float padding = 8f;
                RectF textRect = new RectF(nodeRect.X + padding, nodeRect.Y + padding, nodeRect.Width - 2 * padding, nodeRect.Height - 2 * padding);
                canvas.DrawString(node.Name, textRect, HorizontalAlignment.Center, VerticalAlignment.Center, TextFlow.OverflowBounds); // Use OverflowBounds

                // Draw Connection Handle (+) for Input and Model nodes
                if (node.Type == NodeType.Input || node.Type == NodeType.Model)
                {
                    RectF handleRect = GetConnectionHandleRect(node);
                    canvas.FillColor = handleColor;
                    canvas.StrokeColor = handleStrokeColor;
                    canvas.StrokeSize = 1;

                    // Draw circle handle
                    canvas.FillCircle(handleRect.Center.X, handleRect.Center.Y, HandleSize / 2);
                    canvas.DrawCircle(handleRect.Center.X, handleRect.Center.Y, HandleSize / 2);

                    // Draw '+' inside the handle
                    canvas.StrokeColor = Colors.White; // Color for the '+' symbol
                    canvas.StrokeSize = 1.5f;
                    float plusSize = HandleSize * 0.4f; // Size of the '+' lines
                    canvas.DrawLine(handleRect.Center.X - plusSize, handleRect.Center.Y, handleRect.Center.X + plusSize, handleRect.Center.Y); // Horizontal line
                    canvas.DrawLine(handleRect.Center.X, handleRect.Center.Y - plusSize, handleRect.Center.X, handleRect.Center.Y + plusSize); // Vertical line
                }
            }

            // 4. Draw Legend
            DrawLegend(canvas, dirtyRect, legendBackgroundColor, legendTextColor);
        }

        // Helper to draw a simplified arrowhead (triangle)
        private void DrawArrowhead(ICanvas canvas, PointF start, PointF end)
        {
            float arrowLength = 10;
            float arrowAngleDegrees = 30; // Angle of the arrowhead sides relative to the line

            double angle = Math.Atan2(end.Y - start.Y, end.X - start.X);
            double angleRad1 = angle + Math.PI - (arrowAngleDegrees * Math.PI / 180.0); // Angle for point 1
            double angleRad2 = angle + Math.PI + (arrowAngleDegrees * Math.PI / 180.0); // Angle for point 2

            // Calculate points for the arrowhead triangle relative to the end point
            PointF p1 = new PointF(end.X + arrowLength * (float)Math.Cos(angleRad1),
                                   end.Y + arrowLength * (float)Math.Sin(angleRad1));
            PointF p2 = new PointF(end.X + arrowLength * (float)Math.Cos(angleRad2),
                                   end.Y + arrowLength * (float)Math.Sin(angleRad2));

            // Create path for the arrowhead
            PathF arrowPath = new PathF();
            arrowPath.MoveTo(end); // Tip of the arrow
            arrowPath.LineTo(p1);  // One base point
            arrowPath.LineTo(p2);  // Other base point
            arrowPath.Close();     // Close back to the tip (forms a triangle)

            // Fill the arrowhead (FillColor should be set before calling this)
            canvas.FillPath(arrowPath);
        }

        // Helper to get center point for connections (can be improved)
        private PointF GetConnectionPoint(NodeViewModel node, PointF targetPoint)
        {
            // Simple center point - could be improved to connect to nearest side
            return new PointF(node.Position.X + node.Size.Width / 2, node.Position.Y + node.Size.Height / 2);
        }

        // Helper to get the rectangle for the connection handle
        private RectF GetConnectionHandleRect(NodeViewModel node)
        {
            float handleX = node.Position.X + (node.Size.Width / 2) - (HandleSize / 2);
            float handleY = node.Position.Y + node.Size.Height + HandleOffset;
            return new RectF(handleX, handleY, HandleSize, HandleSize);
        }

        // Helper to determine node color based on DataType primarily
        private Color GetNodeColor(NodeViewModel node, bool isDarkTheme, Color cardBackground, Color surfaceBackground)
        {
            // Create theme-aware versions of node type colors
            Color textDataColor = isDarkTheme ? Color.FromArgb("#253545") : Color.FromArgb("#E6F0FF");
            Color imageDataColor = isDarkTheme ? Color.FromArgb("#253525") : Color.FromArgb("#E6FFE6");
            Color audioDataColor = isDarkTheme ? Color.FromArgb("#352535") : Color.FromArgb("#FFE6F0");
            Color defaultModelColor = isDarkTheme ? Color.FromArgb("#3A3A2A") : Color.FromArgb("#FFFFEC");
            Color unknownDataColor = isDarkTheme ? surfaceBackground.WithLuminosity(surfaceBackground.GetLuminosity() * 1.2f) : surfaceBackground.WithLuminosity(surfaceBackground.GetLuminosity() * 0.9f);
            Color outputNodeColor = isDarkTheme ? Color.FromArgb("#35252A") : Color.FromArgb("#FFF0F0");

            string dataType = node.DataType?.ToLowerInvariant() ?? "unknown";
            string nameLower = node.Name.ToLower();

            // Prioritize DataType property if available and not "unknown"
            if (dataType != "unknown")
            {
                switch (dataType)
                {
                    case "text": return textDataColor;
                    case "image": return imageDataColor;
                    case "audio": return audioDataColor;
                        // Add other specific data types if needed
                }
            }

            // Fallback to name-based inference if DataType is unknown or not set
            // Handle Input Nodes first
            if (node.Type == NodeType.Input)
            {
                if (nameLower.Contains("keyboard") || nameLower.Contains("mouse") || nameLower.Contains("text")) return textDataColor;
                if (nameLower.Contains("camera") || nameLower.Contains("image") || nameLower.Contains("png")) return imageDataColor;
                if (nameLower.Contains("audio") || nameLower.Contains("wav") || nameLower.Contains("mfcc")) return audioDataColor;
                return unknownDataColor; // Fallback for unknown input types
            }
            // Handle Model Nodes (using name as fallback)
            else if (node.Type == NodeType.Model)
            {
                if (nameLower.Contains("llm") || nameLower.Contains("language") || nameLower.Contains("text") || nameLower.Contains("gpt") || nameLower.Contains("bert") || nameLower.Contains("deepseek") || nameLower.Contains("llama") || nameLower.Contains("mistral")) return textDataColor;
                if (nameLower.Contains("vision") || nameLower.Contains("image") || nameLower.Contains("cnn") || nameLower.Contains("resnet") || nameLower.Contains("yolo") || nameLower.Contains("clip") || nameLower.Contains("segmentation") || nameLower.Contains("detection")) return imageDataColor;
                if (nameLower.Contains("audio") || nameLower.Contains("speech") || nameLower.Contains("whisper") || nameLower.Contains("wav2vec") || nameLower.Contains("sound")) return audioDataColor;
                return defaultModelColor; // Fallback for models if type not inferred
            }
            // Output nodes or other types
            else if (node.Type == NodeType.Output)
            {
                return outputNodeColor;
            }
            // Fallback for any other node types
            else
            {
                return unknownDataColor;
            }
        }

        // Helper to draw the legend
        private void DrawLegend(ICanvas canvas, RectF dirtyRect, Color backgroundColor, Color textColor)
        {
            float legendWidth = 100;
            float legendHeight = 70;
            float legendPadding = 10;
            float itemHeight = 15;
            float colorBoxSize = 10;

            // Position legend in top-right corner (adjust as needed)
            float legendX = dirtyRect.Width - legendWidth - legendPadding;
            float legendY = legendPadding; // Positioned below the toolbar area

            RectF legendRect = new RectF(legendX, legendY, legendWidth, legendHeight);

            // Draw background
            canvas.FillColor = backgroundColor;
            canvas.FillRoundedRectangle(legendRect, 5);

            // Draw legend items
            float currentY = legendY + legendPadding / 2;
            canvas.FontColor = textColor;
            canvas.FontSize = 10;

            // Get theme-aware colors
            bool isDarkTheme = Application.Current.RequestedTheme == AppTheme.Dark;
            Color cardBg = Colors.Transparent;
            Color surfaceBg = Colors.Transparent;

            if (Application.Current.Resources.TryGetValue(isDarkTheme ? "CardBackgroundDark" : "CardBackgroundLight", out object cardBgObj))
            {
                cardBg = (Color)cardBgObj;
            }
            if (Application.Current.Resources.TryGetValue(isDarkTheme ? "SurfaceBackgroundDark" : "SurfaceBackgroundLight", out object surfaceBgObj))
            {
                surfaceBg = (Color)surfaceBgObj;
            }

            // Create a dummy node to get the colors for the legend
            var dummyTextNode = new NodeViewModel("", "text", NodeType.Input, new PointF());
            var dummyImageNode = new NodeViewModel("", "image", NodeType.Input, new PointF());
            var dummyAudioNode = new NodeViewModel("", "audio", NodeType.Input, new PointF());
            var dummyModelNode = new NodeViewModel("", "model", NodeType.Model, new PointF());

            // Text Item
            canvas.FillColor = GetNodeColor(dummyTextNode, isDarkTheme, cardBg, surfaceBg);
            canvas.FillRectangle(legendX + legendPadding / 2, currentY, colorBoxSize, colorBoxSize);
            canvas.DrawString("Text Data", legendX + legendPadding / 2 + colorBoxSize + 5, currentY, legendWidth - colorBoxSize - legendPadding, itemHeight, HorizontalAlignment.Left, VerticalAlignment.Center);
            currentY += itemHeight;

            // Image Item
            canvas.FillColor = GetNodeColor(dummyImageNode, isDarkTheme, cardBg, surfaceBg);
            canvas.FillRectangle(legendX + legendPadding / 2, currentY, colorBoxSize, colorBoxSize);
            canvas.DrawString("Image Data", legendX + legendPadding / 2 + colorBoxSize + 5, currentY, legendWidth - colorBoxSize - legendPadding, itemHeight, HorizontalAlignment.Left, VerticalAlignment.Center);
            currentY += itemHeight;

            // Audio Item
            canvas.FillColor = GetNodeColor(dummyAudioNode, isDarkTheme, cardBg, surfaceBg);
            canvas.FillRectangle(legendX + legendPadding / 2, currentY, colorBoxSize, colorBoxSize);
            canvas.DrawString("Audio Data", legendX + legendPadding / 2 + colorBoxSize + 5, currentY, legendWidth - colorBoxSize - legendPadding, itemHeight, HorizontalAlignment.Left, VerticalAlignment.Center);
            currentY += itemHeight;

            // Model Item
            canvas.FillColor = GetNodeColor(dummyModelNode, isDarkTheme, cardBg, surfaceBg);
            canvas.FillRectangle(legendX + legendPadding / 2, currentY, colorBoxSize, colorBoxSize);
            canvas.DrawString("Model (Default)", legendX + legendPadding / 2 + colorBoxSize + 5, currentY, legendWidth - colorBoxSize - legendPadding, itemHeight, HorizontalAlignment.Left, VerticalAlignment.Center);
        }

        // --- Interaction Handlers ---
        // These handlers also depend on NodeCanvas being generated by InitializeComponent

        void OnCanvasStartInteraction(object sender, TouchEventArgs e)
        {
            PointF touchPoint = e.Touches[0];
            NodeViewModel nodeUnderHandle = null;
            bool handleTapped = false;

            // 1. Check if a connection handle was tapped FIRST
            foreach (var node in _viewModel.Nodes)
            {
                if (node.Type == NodeType.Input || node.Type == NodeType.Model)
                {
                    RectF handleRect = GetConnectionHandleRect(node);
                    handleRect.Inflate(2, 2); // Add tolerance

                    if (handleRect.Contains(touchPoint))
                    {
                        nodeUnderHandle = node;
                        handleTapped = true;
                        break; // Found the tapped handle
                    }
                }
            }

            if (handleTapped)
            {
                // Start connection drawing from the handle
                _viewModel.StartConnection(nodeUnderHandle);
                _isDrawingConnection = true;
                _connectionEndPoint = touchPoint; // Initial end point
                _draggedNode = null; // Don't drag if starting connection
                _viewModel.SelectedNode = nodeUnderHandle; // Select the node whose handle was tapped
                Debug.WriteLine($"Started connection from handle of {nodeUnderHandle.Name}");
                _draggedNode = null; // Explicitly ensure no dragging when starting connection
            }
            else
            {
                // 2. If no handle tapped, check if a node body was tapped
                var tappedNode = _viewModel.GetNodeAtPoint(touchPoint); // This should only check node body now

                if (tappedNode != null)
                {
                    // Select/Drag the node
                    _viewModel.SelectedNode = tappedNode;
                    _draggedNode = tappedNode;
                    _dragStartPoint = touchPoint;
                    _isDrawingConnection = false; // Ensure connection drawing is off
                    Debug.WriteLine($"Selected/Dragging node {tappedNode.Name}");
                }
                else
                {
                    // 3. Tapped empty space
                    _viewModel.SelectedNode = null;
                    _draggedNode = null;
                    _viewModel.CancelConnection();
                    _isDrawingConnection = false;
                    Debug.WriteLine("Tapped empty space.");
                }
            }

            NodeCanvas.Invalidate(); // Redraw for selection/connection feedback
            // Add log for start point
            Debug.WriteLine($"StartInteraction at {e.Touches[0]}");
        }

        void OnCanvasDragInteraction(object sender, TouchEventArgs e)
        {
            PointF currentPoint = e.Touches[0];
            // Add log for drag point
            // Debug.WriteLine($"DragInteraction at {currentPoint}");

            if (_draggedNode != null)
            {
                // Calculate delta and update node position in ViewModel
                float deltaX = currentPoint.X - _dragStartPoint.X;
                float deltaY = currentPoint.Y - _dragStartPoint.Y;
                PointF newPos = new PointF(_draggedNode.Position.X + deltaX, _draggedNode.Position.Y + deltaY);

                _viewModel.UpdateNodePosition(_draggedNode, newPos);

                _dragStartPoint = currentPoint; // Update start point for next delta
                NodeCanvas.Invalidate(); // Request redraw
            }
            else if (_isDrawingConnection)
            {
                _connectionEndPoint = currentPoint;
                // _viewModel.UpdatePotentialConnection(currentPoint); // Keep if VM uses it
                NodeCanvas.Invalidate(); // Redraw temporary line
            }
        }

        async void OnCanvasEndInteraction(object sender, TouchEventArgs e) // Made async
        {
            PointF endPoint = e.Touches[0]; // Use the first touch point
            Debug.WriteLine($"EndInteraction at {endPoint}. IsDrawingConnection: {_isDrawingConnection}");

            if (_isDrawingConnection)
            {
                Debug.WriteLine("Attempting to complete connection...");
                NodeViewModel targetNode = null;
                float tolerance = 20f; // Increased tolerance significantly for testing

                // Manually check for target node instead of relying solely on ViewModel method
                Debug.WriteLine($"--- Checking nodes at EndPoint {endPoint} with tolerance {tolerance} ---");
                foreach (var node in _viewModel.Nodes)
                {
                    // Create a slightly larger rectangle for hit testing
                    RectF nodeBounds = new RectF(node.Position, node.Size);
                    nodeBounds.Inflate(tolerance, tolerance);

                    Debug.WriteLine($"Checking Node: {node.Name}, Bounds (Inflated): {nodeBounds}");

                    if (nodeBounds.Contains(endPoint))
                    {
                        Debug.WriteLine($"   -> EndPoint {endPoint} IS within bounds of {node.Name}.");
                        // Ensure we are not connecting a node to itself (unless allowed by VM logic)
                        if (_viewModel._temporaryConnectionState is NodeViewModel sourceNode && sourceNode.Id != node.Id)
                        {
                            Debug.WriteLine($"   -> Valid target found: {node.Name}.");
                            targetNode = node;
                            break; // Found a valid target node
                        }
                        else if (_viewModel._temporaryConnectionState is NodeViewModel sourceNodeSelf)
                        {
                            Debug.WriteLine($"   -> Hit node {node.Name}, but it's the same as the start node ({sourceNodeSelf.Name}). Skipping.");
                        }
                        else
                        {
                            Debug.WriteLine($"   -> Hit node {node.Name}, but start node state is invalid. Skipping.");
                        }
                    }
                    else
                    {
                        Debug.WriteLine($"   -> EndPoint {endPoint} is NOT within bounds of {node.Name}.");
                    }
                }
                Debug.WriteLine($"--- Finished checking nodes ---");


                if (targetNode != null)
                {
                    Debug.WriteLine($"Found target node manually: {targetNode.Name}. Calling CompleteConnection.");
                    // *** IMPORTANT: Add logging INSIDE _viewModel.CompleteConnection ***
                    // *** to confirm it adds the connection to the ObservableCollection ***
                    _viewModel.CompleteConnection(targetNode);
                }
                else
                {
                    // Fallback check removed for clarity, focus on manual hit test first
                    Debug.WriteLine("No valid target node found manually at end point. Cancelling connection.");
                    _viewModel.CancelConnection(); // Explicitly cancel if ending on empty space
                }
                _isDrawingConnection = false; // Reset connection drawing state *after* handling
            }
            else if (_draggedNode != null)
            {
                Debug.WriteLine($"Ended drag for node: {_draggedNode.Name}");
                // Saving now happens during drag via UpdateNodePosition.
                // No need to call FinalizeNodeMove here anymore.
                await _viewModel.FinalizeNodeMove(); // Re-enabled this call
            }

            _draggedNode = null; // Stop dragging regardless of connection state
            // Invalidation should happen automatically due to CollectionChanged,
            // but an explicit call ensures redraw after state changes.
            NodeCanvas.Invalidate();
            Debug.WriteLine("EndInteraction finished.");
        }

        void OnCanvasCancelInteraction(object sender, EventArgs e)
        {
            Debug.WriteLine("CancelInteraction triggered.");
            // Handle cancellation (e.g., touch moved off screen)
            _draggedNode = null;
            if (_isDrawingConnection)
            {
                Debug.WriteLine("Cancelling connection drawing due to CancelInteraction.");
                _viewModel.CancelConnection();
                _isDrawingConnection = false;
                NodeCanvas.Invalidate();
            }
        }

        // Add this method to allow the ViewModel to request a redraw
        public void InvalidateGraphicsView()
        {
            NodeCanvas?.Invalidate();
        }

        // Add this event handler for the Run Node button
        private async void OnRunNodeClicked(object sender, EventArgs e)
        {
            if (_viewModel.SelectedNode == null)
            {
                return;
            }

            try
            {
                // Show loading state
                var button = sender as Button;
                if (button != null)
                {
                    var originalText = button.Text;
                    button.Text = "Running...";
                    button.IsEnabled = false;

                    // Execute the node
                    var node = _viewModel.SelectedNode;
                    string result = await ExecuteNodeAsync(node);
                    _viewModel.NodeOutputText = result;

                    // Restore button
                    button.Text = originalText;
                    button.IsEnabled = true;
                }
            }
            catch (Exception ex)
            {
                _viewModel.NodeOutputText = $"Error: {ex.Message}";
                Debug.WriteLine($"Error executing node: {ex}");

                // Restore button state if error occurs
                if (sender is Button btn)
                {
                    btn.Text = "Run Node";
                    btn.IsEnabled = true;
                }
            }
        }

        // Helper method to execute a node
        private async Task<string> ExecuteNodeAsync(NodeViewModel node)
        {
            if (node == null) return "No node selected";

            // Show different output based on node type
            switch (node.Type)
            {
                case NodeType.Input:
                    return $"Input Node: '{node.Name}'\nSimulated {node.DataType ?? "data"} input would be captured here.";

                case NodeType.Model:
                    // For model nodes, attempt to simulate model execution
                    string modelInfo = $"Model Node: '{node.Name}'\n";

                    if (!string.IsNullOrEmpty(node.ModelPath))
                    {
                        modelInfo += $"Model ID: {node.ModelPath}\n";
                    }

                    // Check incoming connections
                    var incomingConnections = _viewModel.Connections
                        .Where(c => c.TargetNodeId == node.Id)
                        .ToList();

                    if (incomingConnections.Any())
                    {
                        modelInfo += $"Receives input from {incomingConnections.Count} node(s).\n";

                        // Show ensemble details if applicable
                        if (incomingConnections.Count > 1 && !string.IsNullOrEmpty(node.SelectedEnsembleMethod))
                        {
                            modelInfo += $"Using ensemble method: {node.SelectedEnsembleMethod}\n";
                        }
                    }
                    else
                    {
                        modelInfo += "No input connections. This model needs input data.\n";
                    }

                    // Add a simulated result
                    modelInfo += "\nSimulated output: [Model processing would execute here]";

                    // For text models with classification, add special output
                    if (node.IsTextModel && !string.IsNullOrEmpty(node.Classification))
                    {
                        modelInfo += $"\n\nClassified as: {node.Classification}";

                        // Add different responses based on classification
                        switch (node.Classification)
                        {
                            case "Goal":
                                modelInfo += "\nGoal models define high-level objectives.";
                                break;
                            case "Plan":
                                modelInfo += "\nPlan models break down goals into steps.";
                                break;
                            case "Action":
                                modelInfo += "\nAction models execute specific tasks.";
                                break;
                        }
                    }

                    return modelInfo;

                case NodeType.Output:
                    return $"Output Node: '{node.Name}'\nWould display or save results here.";

                default:
                    return $"Unknown node type: {node.Type}";
            }
        }
    }
}
